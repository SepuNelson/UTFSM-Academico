// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: lab.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GobiernoMundial_ListarPiratasBuscados_FullMethodName           = "/sistema.GobiernoMundial/ListarPiratasBuscados"
	GobiernoMundial_RegistrarCaptura_FullMethodName                = "/sistema.GobiernoMundial/RegistrarCaptura"
	GobiernoMundial_ActualizarReputacion_FullMethodName            = "/sistema.GobiernoMundial/ActualizarReputacion"
	GobiernoMundial_AlertarMarina_FullMethodName                   = "/sistema.GobiernoMundial/AlertarMarina"
	GobiernoMundial_ConsultarEstadoCazarrecompensas_FullMethodName = "/sistema.GobiernoMundial/ConsultarEstadoCazarrecompensas"
	GobiernoMundial_RegistrarCazarrecompensas_FullMethodName       = "/sistema.GobiernoMundial/RegistrarCazarrecompensas"
	GobiernoMundial_ActualizarEstadoPirata_FullMethodName          = "/sistema.GobiernoMundial/ActualizarEstadoPirata"
)

// GobiernoMundialClient is the client API for GobiernoMundial service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GobiernoMundialClient interface {
	ListarPiratasBuscados(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error)
	RegistrarCaptura(ctx context.Context, in *SolicitudCaptura, opts ...grpc.CallOption) (*ResultadoCaptura, error)
	ActualizarReputacion(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AlertarMarina(ctx context.Context, in *AlertaActividad, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConsultarEstadoCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error)
	RegistrarCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*ResultadoCaptura, error)
	ActualizarEstadoPirata(ctx context.Context, in *Pirata, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type gobiernoMundialClient struct {
	cc grpc.ClientConnInterface
}

func NewGobiernoMundialClient(cc grpc.ClientConnInterface) GobiernoMundialClient {
	return &gobiernoMundialClient{cc}
}

func (c *gobiernoMundialClient) ListarPiratasBuscados(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListaPiratas)
	err := c.cc.Invoke(ctx, GobiernoMundial_ListarPiratasBuscados_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) RegistrarCaptura(ctx context.Context, in *SolicitudCaptura, opts ...grpc.CallOption) (*ResultadoCaptura, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoCaptura)
	err := c.cc.Invoke(ctx, GobiernoMundial_RegistrarCaptura_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) ActualizarReputacion(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GobiernoMundial_ActualizarReputacion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) AlertarMarina(ctx context.Context, in *AlertaActividad, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GobiernoMundial_AlertarMarina_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) ConsultarEstadoCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EstadoCazarrecompensas)
	err := c.cc.Invoke(ctx, GobiernoMundial_ConsultarEstadoCazarrecompensas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) RegistrarCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*ResultadoCaptura, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoCaptura)
	err := c.cc.Invoke(ctx, GobiernoMundial_RegistrarCazarrecompensas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gobiernoMundialClient) ActualizarEstadoPirata(ctx context.Context, in *Pirata, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GobiernoMundial_ActualizarEstadoPirata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GobiernoMundialServer is the server API for GobiernoMundial service.
// All implementations must embed UnimplementedGobiernoMundialServer
// for forward compatibility.
type GobiernoMundialServer interface {
	ListarPiratasBuscados(context.Context, *emptypb.Empty) (*ListaPiratas, error)
	RegistrarCaptura(context.Context, *SolicitudCaptura) (*ResultadoCaptura, error)
	ActualizarReputacion(context.Context, *EstadoCazarrecompensas) (*emptypb.Empty, error)
	AlertarMarina(context.Context, *AlertaActividad) (*emptypb.Empty, error)
	ConsultarEstadoCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*EstadoCazarrecompensas, error)
	RegistrarCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*ResultadoCaptura, error)
	ActualizarEstadoPirata(context.Context, *Pirata) (*emptypb.Empty, error)
	mustEmbedUnimplementedGobiernoMundialServer()
}

// UnimplementedGobiernoMundialServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGobiernoMundialServer struct{}

func (UnimplementedGobiernoMundialServer) ListarPiratasBuscados(context.Context, *emptypb.Empty) (*ListaPiratas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListarPiratasBuscados not implemented")
}
func (UnimplementedGobiernoMundialServer) RegistrarCaptura(context.Context, *SolicitudCaptura) (*ResultadoCaptura, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistrarCaptura not implemented")
}
func (UnimplementedGobiernoMundialServer) ActualizarReputacion(context.Context, *EstadoCazarrecompensas) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActualizarReputacion not implemented")
}
func (UnimplementedGobiernoMundialServer) AlertarMarina(context.Context, *AlertaActividad) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlertarMarina not implemented")
}
func (UnimplementedGobiernoMundialServer) ConsultarEstadoCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*EstadoCazarrecompensas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsultarEstadoCazarrecompensas not implemented")
}
func (UnimplementedGobiernoMundialServer) RegistrarCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*ResultadoCaptura, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistrarCazarrecompensas not implemented")
}
func (UnimplementedGobiernoMundialServer) ActualizarEstadoPirata(context.Context, *Pirata) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActualizarEstadoPirata not implemented")
}
func (UnimplementedGobiernoMundialServer) mustEmbedUnimplementedGobiernoMundialServer() {}
func (UnimplementedGobiernoMundialServer) testEmbeddedByValue()                         {}

// UnsafeGobiernoMundialServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GobiernoMundialServer will
// result in compilation errors.
type UnsafeGobiernoMundialServer interface {
	mustEmbedUnimplementedGobiernoMundialServer()
}

func RegisterGobiernoMundialServer(s grpc.ServiceRegistrar, srv GobiernoMundialServer) {
	// If the following call pancis, it indicates UnimplementedGobiernoMundialServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GobiernoMundial_ServiceDesc, srv)
}

func _GobiernoMundial_ListarPiratasBuscados_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).ListarPiratasBuscados(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_ListarPiratasBuscados_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).ListarPiratasBuscados(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_RegistrarCaptura_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolicitudCaptura)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).RegistrarCaptura(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_RegistrarCaptura_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).RegistrarCaptura(ctx, req.(*SolicitudCaptura))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_ActualizarReputacion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstadoCazarrecompensas)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).ActualizarReputacion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_ActualizarReputacion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).ActualizarReputacion(ctx, req.(*EstadoCazarrecompensas))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_AlertarMarina_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertaActividad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).AlertarMarina(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_AlertarMarina_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).AlertarMarina(ctx, req.(*AlertaActividad))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_ConsultarEstadoCazarrecompensas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstadoCazarrecompensas)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).ConsultarEstadoCazarrecompensas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_ConsultarEstadoCazarrecompensas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).ConsultarEstadoCazarrecompensas(ctx, req.(*EstadoCazarrecompensas))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_RegistrarCazarrecompensas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstadoCazarrecompensas)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).RegistrarCazarrecompensas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_RegistrarCazarrecompensas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).RegistrarCazarrecompensas(ctx, req.(*EstadoCazarrecompensas))
	}
	return interceptor(ctx, in, info, handler)
}

func _GobiernoMundial_ActualizarEstadoPirata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pirata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GobiernoMundialServer).ActualizarEstadoPirata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GobiernoMundial_ActualizarEstadoPirata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GobiernoMundialServer).ActualizarEstadoPirata(ctx, req.(*Pirata))
	}
	return interceptor(ctx, in, info, handler)
}

// GobiernoMundial_ServiceDesc is the grpc.ServiceDesc for GobiernoMundial service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GobiernoMundial_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sistema.GobiernoMundial",
	HandlerType: (*GobiernoMundialServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListarPiratasBuscados",
			Handler:    _GobiernoMundial_ListarPiratasBuscados_Handler,
		},
		{
			MethodName: "RegistrarCaptura",
			Handler:    _GobiernoMundial_RegistrarCaptura_Handler,
		},
		{
			MethodName: "ActualizarReputacion",
			Handler:    _GobiernoMundial_ActualizarReputacion_Handler,
		},
		{
			MethodName: "AlertarMarina",
			Handler:    _GobiernoMundial_AlertarMarina_Handler,
		},
		{
			MethodName: "ConsultarEstadoCazarrecompensas",
			Handler:    _GobiernoMundial_ConsultarEstadoCazarrecompensas_Handler,
		},
		{
			MethodName: "RegistrarCazarrecompensas",
			Handler:    _GobiernoMundial_RegistrarCazarrecompensas_Handler,
		},
		{
			MethodName: "ActualizarEstadoPirata",
			Handler:    _GobiernoMundial_ActualizarEstadoPirata_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lab.proto",
}

const (
	Cazarrecompensas_TransportarPirata_FullMethodName               = "/sistema.Cazarrecompensas/TransportarPirata"
	Cazarrecompensas_ConsultarEstado_FullMethodName                 = "/sistema.Cazarrecompensas/ConsultarEstado"
	Cazarrecompensas_ConsultarListaPiratas_FullMethodName           = "/sistema.Cazarrecompensas/ConsultarListaPiratas"
	Cazarrecompensas_ConsultarEstadoCazarrecompensas_FullMethodName = "/sistema.Cazarrecompensas/ConsultarEstadoCazarrecompensas"
)

// CazarrecompensasClient is the client API for Cazarrecompensas service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CazarrecompensasClient interface {
	TransportarPirata(ctx context.Context, in *Transporte, opts ...grpc.CallOption) (*ResultadoTransporte, error)
	ConsultarEstado(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error)
	ConsultarListaPiratas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error)
	ConsultarEstadoCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error)
}

type cazarrecompensasClient struct {
	cc grpc.ClientConnInterface
}

func NewCazarrecompensasClient(cc grpc.ClientConnInterface) CazarrecompensasClient {
	return &cazarrecompensasClient{cc}
}

func (c *cazarrecompensasClient) TransportarPirata(ctx context.Context, in *Transporte, opts ...grpc.CallOption) (*ResultadoTransporte, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoTransporte)
	err := c.cc.Invoke(ctx, Cazarrecompensas_TransportarPirata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cazarrecompensasClient) ConsultarEstado(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EstadoCazarrecompensas)
	err := c.cc.Invoke(ctx, Cazarrecompensas_ConsultarEstado_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cazarrecompensasClient) ConsultarListaPiratas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListaPiratas)
	err := c.cc.Invoke(ctx, Cazarrecompensas_ConsultarListaPiratas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cazarrecompensasClient) ConsultarEstadoCazarrecompensas(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*EstadoCazarrecompensas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EstadoCazarrecompensas)
	err := c.cc.Invoke(ctx, Cazarrecompensas_ConsultarEstadoCazarrecompensas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CazarrecompensasServer is the server API for Cazarrecompensas service.
// All implementations must embed UnimplementedCazarrecompensasServer
// for forward compatibility.
type CazarrecompensasServer interface {
	TransportarPirata(context.Context, *Transporte) (*ResultadoTransporte, error)
	ConsultarEstado(context.Context, *emptypb.Empty) (*EstadoCazarrecompensas, error)
	ConsultarListaPiratas(context.Context, *emptypb.Empty) (*ListaPiratas, error)
	ConsultarEstadoCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*EstadoCazarrecompensas, error)
	mustEmbedUnimplementedCazarrecompensasServer()
}

// UnimplementedCazarrecompensasServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCazarrecompensasServer struct{}

func (UnimplementedCazarrecompensasServer) TransportarPirata(context.Context, *Transporte) (*ResultadoTransporte, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransportarPirata not implemented")
}
func (UnimplementedCazarrecompensasServer) ConsultarEstado(context.Context, *emptypb.Empty) (*EstadoCazarrecompensas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsultarEstado not implemented")
}
func (UnimplementedCazarrecompensasServer) ConsultarListaPiratas(context.Context, *emptypb.Empty) (*ListaPiratas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsultarListaPiratas not implemented")
}
func (UnimplementedCazarrecompensasServer) ConsultarEstadoCazarrecompensas(context.Context, *EstadoCazarrecompensas) (*EstadoCazarrecompensas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsultarEstadoCazarrecompensas not implemented")
}
func (UnimplementedCazarrecompensasServer) mustEmbedUnimplementedCazarrecompensasServer() {}
func (UnimplementedCazarrecompensasServer) testEmbeddedByValue()                          {}

// UnsafeCazarrecompensasServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CazarrecompensasServer will
// result in compilation errors.
type UnsafeCazarrecompensasServer interface {
	mustEmbedUnimplementedCazarrecompensasServer()
}

func RegisterCazarrecompensasServer(s grpc.ServiceRegistrar, srv CazarrecompensasServer) {
	// If the following call pancis, it indicates UnimplementedCazarrecompensasServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Cazarrecompensas_ServiceDesc, srv)
}

func _Cazarrecompensas_TransportarPirata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transporte)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CazarrecompensasServer).TransportarPirata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cazarrecompensas_TransportarPirata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CazarrecompensasServer).TransportarPirata(ctx, req.(*Transporte))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cazarrecompensas_ConsultarEstado_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CazarrecompensasServer).ConsultarEstado(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cazarrecompensas_ConsultarEstado_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CazarrecompensasServer).ConsultarEstado(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cazarrecompensas_ConsultarListaPiratas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CazarrecompensasServer).ConsultarListaPiratas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cazarrecompensas_ConsultarListaPiratas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CazarrecompensasServer).ConsultarListaPiratas(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cazarrecompensas_ConsultarEstadoCazarrecompensas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstadoCazarrecompensas)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CazarrecompensasServer).ConsultarEstadoCazarrecompensas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cazarrecompensas_ConsultarEstadoCazarrecompensas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CazarrecompensasServer).ConsultarEstadoCazarrecompensas(ctx, req.(*EstadoCazarrecompensas))
	}
	return interceptor(ctx, in, info, handler)
}

// Cazarrecompensas_ServiceDesc is the grpc.ServiceDesc for Cazarrecompensas service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cazarrecompensas_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sistema.Cazarrecompensas",
	HandlerType: (*CazarrecompensasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TransportarPirata",
			Handler:    _Cazarrecompensas_TransportarPirata_Handler,
		},
		{
			MethodName: "ConsultarEstado",
			Handler:    _Cazarrecompensas_ConsultarEstado_Handler,
		},
		{
			MethodName: "ConsultarListaPiratas",
			Handler:    _Cazarrecompensas_ConsultarListaPiratas_Handler,
		},
		{
			MethodName: "ConsultarEstadoCazarrecompensas",
			Handler:    _Cazarrecompensas_ConsultarEstadoCazarrecompensas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lab.proto",
}

const (
	Marina_RecibirPirata_FullMethodName         = "/sistema.Marina/RecibirPirata"
	Marina_RecibirAlerta_FullMethodName         = "/sistema.Marina/RecibirAlerta"
	Marina_ConsultarListaPiratas_FullMethodName = "/sistema.Marina/ConsultarListaPiratas"
	Marina_NotificarGobierno_FullMethodName     = "/sistema.Marina/NotificarGobierno"
)

// MarinaClient is the client API for Marina service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarinaClient interface {
	RecibirPirata(ctx context.Context, in *EntregaPirata, opts ...grpc.CallOption) (*ResultadoEntrega, error)
	RecibirAlerta(ctx context.Context, in *AlertaActividad, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConsultarListaPiratas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error)
	NotificarGobierno(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type marinaClient struct {
	cc grpc.ClientConnInterface
}

func NewMarinaClient(cc grpc.ClientConnInterface) MarinaClient {
	return &marinaClient{cc}
}

func (c *marinaClient) RecibirPirata(ctx context.Context, in *EntregaPirata, opts ...grpc.CallOption) (*ResultadoEntrega, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoEntrega)
	err := c.cc.Invoke(ctx, Marina_RecibirPirata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marinaClient) RecibirAlerta(ctx context.Context, in *AlertaActividad, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Marina_RecibirAlerta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marinaClient) ConsultarListaPiratas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListaPiratas, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListaPiratas)
	err := c.cc.Invoke(ctx, Marina_ConsultarListaPiratas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marinaClient) NotificarGobierno(ctx context.Context, in *EstadoCazarrecompensas, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Marina_NotificarGobierno_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarinaServer is the server API for Marina service.
// All implementations must embed UnimplementedMarinaServer
// for forward compatibility.
type MarinaServer interface {
	RecibirPirata(context.Context, *EntregaPirata) (*ResultadoEntrega, error)
	RecibirAlerta(context.Context, *AlertaActividad) (*emptypb.Empty, error)
	ConsultarListaPiratas(context.Context, *emptypb.Empty) (*ListaPiratas, error)
	NotificarGobierno(context.Context, *EstadoCazarrecompensas) (*emptypb.Empty, error)
	mustEmbedUnimplementedMarinaServer()
}

// UnimplementedMarinaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMarinaServer struct{}

func (UnimplementedMarinaServer) RecibirPirata(context.Context, *EntregaPirata) (*ResultadoEntrega, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecibirPirata not implemented")
}
func (UnimplementedMarinaServer) RecibirAlerta(context.Context, *AlertaActividad) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecibirAlerta not implemented")
}
func (UnimplementedMarinaServer) ConsultarListaPiratas(context.Context, *emptypb.Empty) (*ListaPiratas, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsultarListaPiratas not implemented")
}
func (UnimplementedMarinaServer) NotificarGobierno(context.Context, *EstadoCazarrecompensas) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotificarGobierno not implemented")
}
func (UnimplementedMarinaServer) mustEmbedUnimplementedMarinaServer() {}
func (UnimplementedMarinaServer) testEmbeddedByValue()                {}

// UnsafeMarinaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarinaServer will
// result in compilation errors.
type UnsafeMarinaServer interface {
	mustEmbedUnimplementedMarinaServer()
}

func RegisterMarinaServer(s grpc.ServiceRegistrar, srv MarinaServer) {
	// If the following call pancis, it indicates UnimplementedMarinaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Marina_ServiceDesc, srv)
}

func _Marina_RecibirPirata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntregaPirata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarinaServer).RecibirPirata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marina_RecibirPirata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarinaServer).RecibirPirata(ctx, req.(*EntregaPirata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marina_RecibirAlerta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlertaActividad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarinaServer).RecibirAlerta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marina_RecibirAlerta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarinaServer).RecibirAlerta(ctx, req.(*AlertaActividad))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marina_ConsultarListaPiratas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarinaServer).ConsultarListaPiratas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marina_ConsultarListaPiratas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarinaServer).ConsultarListaPiratas(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Marina_NotificarGobierno_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstadoCazarrecompensas)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarinaServer).NotificarGobierno(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Marina_NotificarGobierno_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarinaServer).NotificarGobierno(ctx, req.(*EstadoCazarrecompensas))
	}
	return interceptor(ctx, in, info, handler)
}

// Marina_ServiceDesc is the grpc.ServiceDesc for Marina service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Marina_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sistema.Marina",
	HandlerType: (*MarinaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecibirPirata",
			Handler:    _Marina_RecibirPirata_Handler,
		},
		{
			MethodName: "RecibirAlerta",
			Handler:    _Marina_RecibirAlerta_Handler,
		},
		{
			MethodName: "ConsultarListaPiratas",
			Handler:    _Marina_ConsultarListaPiratas_Handler,
		},
		{
			MethodName: "NotificarGobierno",
			Handler:    _Marina_NotificarGobierno_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lab.proto",
}

const (
	Submundo_ComprarPirata_FullMethodName         = "/sistema.Submundo/ComprarPirata"
	Submundo_InterceptarTransporte_FullMethodName = "/sistema.Submundo/InterceptarTransporte"
)

// SubmundoClient is the client API for Submundo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubmundoClient interface {
	ComprarPirata(ctx context.Context, in *EntregaPirata, opts ...grpc.CallOption) (*ResultadoEntrega, error)
	InterceptarTransporte(ctx context.Context, in *Pirata, opts ...grpc.CallOption) (*ResultadoTransporte, error)
}

type submundoClient struct {
	cc grpc.ClientConnInterface
}

func NewSubmundoClient(cc grpc.ClientConnInterface) SubmundoClient {
	return &submundoClient{cc}
}

func (c *submundoClient) ComprarPirata(ctx context.Context, in *EntregaPirata, opts ...grpc.CallOption) (*ResultadoEntrega, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoEntrega)
	err := c.cc.Invoke(ctx, Submundo_ComprarPirata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submundoClient) InterceptarTransporte(ctx context.Context, in *Pirata, opts ...grpc.CallOption) (*ResultadoTransporte, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResultadoTransporte)
	err := c.cc.Invoke(ctx, Submundo_InterceptarTransporte_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubmundoServer is the server API for Submundo service.
// All implementations must embed UnimplementedSubmundoServer
// for forward compatibility.
type SubmundoServer interface {
	ComprarPirata(context.Context, *EntregaPirata) (*ResultadoEntrega, error)
	InterceptarTransporte(context.Context, *Pirata) (*ResultadoTransporte, error)
	mustEmbedUnimplementedSubmundoServer()
}

// UnimplementedSubmundoServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubmundoServer struct{}

func (UnimplementedSubmundoServer) ComprarPirata(context.Context, *EntregaPirata) (*ResultadoEntrega, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComprarPirata not implemented")
}
func (UnimplementedSubmundoServer) InterceptarTransporte(context.Context, *Pirata) (*ResultadoTransporte, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterceptarTransporte not implemented")
}
func (UnimplementedSubmundoServer) mustEmbedUnimplementedSubmundoServer() {}
func (UnimplementedSubmundoServer) testEmbeddedByValue()                  {}

// UnsafeSubmundoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubmundoServer will
// result in compilation errors.
type UnsafeSubmundoServer interface {
	mustEmbedUnimplementedSubmundoServer()
}

func RegisterSubmundoServer(s grpc.ServiceRegistrar, srv SubmundoServer) {
	// If the following call pancis, it indicates UnimplementedSubmundoServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Submundo_ServiceDesc, srv)
}

func _Submundo_ComprarPirata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EntregaPirata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmundoServer).ComprarPirata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submundo_ComprarPirata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmundoServer).ComprarPirata(ctx, req.(*EntregaPirata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submundo_InterceptarTransporte_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pirata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmundoServer).InterceptarTransporte(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submundo_InterceptarTransporte_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmundoServer).InterceptarTransporte(ctx, req.(*Pirata))
	}
	return interceptor(ctx, in, info, handler)
}

// Submundo_ServiceDesc is the grpc.ServiceDesc for Submundo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Submundo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sistema.Submundo",
	HandlerType: (*SubmundoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ComprarPirata",
			Handler:    _Submundo_ComprarPirata_Handler,
		},
		{
			MethodName: "InterceptarTransporte",
			Handler:    _Submundo_InterceptarTransporte_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lab.proto",
}
